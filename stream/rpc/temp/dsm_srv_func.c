/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "rpc_dsm.h"
#include "dsm_clnt_func.h"
// #include "../../config.h"
#include "../../main/window.h"

extern window *win[];
extern char *ip_list[];
extern int local_node;

int fill_param(para_4 *param) {
    int node = param->node;
    int num = param->num;
	int first = win[node]->first;
	int second = win[node]->second;
    if(num == -1) {
        param->length = win[node]->length;
        param->first = win[node]->first;
        param->second = win[node]->second;
        param->third = win[node]->third;
    } else if((first <= second && num >= first && num <= second) || (first > second && (num >= first || num <= second))) {
		memcpy(param->buff, (win[node]->pane)[num], sizeof(pane));
    } else {
		return 1;
	}
	return 0;
}

int *
write_data_1_svc(para_1 *argp, struct svc_req *rqstp)
{
	static int  result;

	/*
	 * insert server code here
	 */
	result = windowDataIn(win[argp->node], argp->buff, argp->len);
	INFO("write_data_remote, node = %d, len = %d, buff = %c",argp->node, argp->len, (argp->buff)[0]);
	return &result;
}

int *
read_data_1_svc(para_2 *argp, struct svc_req *rqstp)
{
	static int  result;

	/*
	 * insert server code here
	 */
	for(int i = 0; i < NODE_NUM; ++i) {
		for(int j = -1; j < PANE_NUM; ++j) {
			para_4 param;
			param.node = i;
			param.num = j;
			result = fill_param(&param);
			if(result == 1) {
				result = 0;
				continue;
			}
			result = rm_recover_data(ip_list[argp->node], &param);
			if(result != 0) {
				INFO("read_data_1_svc->rm_recover_data error, node %d help node %d recover, ret = %d", local_node, argp->node + 1, result);
				return &result;
			}
		}
	}

	INFO("read_data_1_svc, node %d help node %d recover", local_node, argp->node + 1);
	return &result;
}

int *
delete_data_1_svc(para_3 *argp, struct svc_req *rqstp)
{
	static int  result;

	/*
	 * insert server code here
	 */
	char buff[1024];
	int len = 0;
	result = windowDataOut(win[argp->node], buff, &len);
	INFO("delete_data_remote, node = %d, len = %d, buff = %c",argp->node, len, buff[0]);
	return &result;
}

int *
recover_data_1_svc(para_4 *argp, struct svc_req *rqstp)
{
	static int  result;

	/*
	 * insert server code here
	 */
	int node = argp->node;
	int num = argp->num;
	if(num == -1) {
		win[node]->length = argp->length;
		win[node]->first = argp->first;
		win[node]->second = argp->second;
		win[node]->third = argp->third;
		result = windowReInit(&win[node]);
		if(result != 0) {
			INFO("windowReInit fail, node = %d, num = %d, result = %d",node, num, result);
			return &result;
		}
	} else {
		memcpy((win[node]->pane)[num], argp->buff, sizeof(pane));
	}
	INFO("recover_data_1_svc, node = %d, num = %d",node, num);
	result = 0;
	return &result;
}
